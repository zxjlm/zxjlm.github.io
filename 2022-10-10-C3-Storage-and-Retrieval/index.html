<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="theme-color" content="#0078E7"><meta name="author" content="harumonia"><meta name="copyright" content="harumonia"><meta name="generator" content="Hexo 6.0.0"><meta name="theme" content="hexo-theme-yun"><title>C3. Storage and Retrieval (更新中) | Zaxon</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="//at.alicdn.com/t/font_1140697_j5gk85dg4pf.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://cdn.jsdelivr.net/npm/" crossorigin><script id="yun-config">window.Yun={},window.CONFIG={hostname:"blog.harumonia.moe",root:"/",title:"迷雾中的藏宝地",version:"1.10.9",mode:"auto",copycode:!0,page:{isPost:!0},i18n:{placeholder:"搜索...",empty:"找不到您查询的内容: ${query}",hits:"找到 ${hits} 条结果",hits_time:"找到 ${hits} 条结果（用时 ${time} 毫秒）"},anonymous_image:"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg",say:{api:"https://v1.hitokoto.cn",hitokoto:!0},fireworks:{colors:["102, 167, 221","62, 131, 225","33, 78, 194"]},vendors:{host:"https://cdn.jsdelivr.net/npm/",darken:"https://cdn.jsdelivr.net/npm/darken@1.5.0"}}</script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><link rel="alternate" href="/atom.xml" title="Zaxon" type="application/atom+xml"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-EBNGE3F0F6"></script><script>function gtag(){dataLayer.push(arguments)}CONFIG.hostname===location.hostname&&(window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-EBNGE3F0F6"))</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><meta name="description" content="Data Structure That Power Your Database最简单的数据库是什么样子的? #!&#x2F;bin&#x2F;bash  db_set () &amp;#123;       echo &quot;$1,$2&quot; &gt;&gt; database  &amp;#125;   db_get () &amp;#123;       grep &quot;^$1,&quot; database | sed -e &quot;s&#x2F;^$1,&#x2F;&#x2F;&quot; | tail -n 1"><meta property="og:type" content="article"><meta property="og:title" content="C3. Storage and Retrieval (更新中)"><meta property="og:url" content="https://blog.harumonia.moe/2022-10-10-C3-Storage-and-Retrieval/index.html"><meta property="og:site_name" content="Zaxon"><meta property="og:description" content="Data Structure That Power Your Database最简单的数据库是什么样子的? #!&#x2F;bin&#x2F;bash  db_set () &amp;#123;       echo &quot;$1,$2&quot; &gt;&gt; database  &amp;#125;   db_get () &amp;#123;       grep &quot;^$1,&quot; database | sed -e &quot;s&#x2F;^$1,&#x2F;&#x2F;&quot; | tail -n 1"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/zxjlm/my-static-files/main/img/20220818141020.png"><meta property="og:image" content="https://raw.githubusercontent.com/zxjlm/my-static-files/main/img/20220818150445.png"><meta property="og:image" content="https://raw.githubusercontent.com/zxjlm/my-static-files/main/img/20220902161015.png"><meta property="article:published_time" content="2022-10-10T17:22:24.000Z"><meta property="article:modified_time" content="2023-01-07T14:54:24.000Z"><meta property="article:author" content="harumonia"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://raw.githubusercontent.com/zxjlm/my-static-files/main/img/20220818141020.png"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>IconifyProviders={"":{resources:["https://api.iconify.design"],rotate:1e3}}</script><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="harumonia"><img width="96" loading="lazy" src="https://harumona-blog.oss-cn-beijing.aliyuncs.com/blog/Ocabe.webp" alt="harumonia"></a><div class="site-author-name"><a href="/about/">harumonia</a></div><span class="site-name">Zaxon</span><sub class="site-subtitle">Find the key of soul</sub><div class="site-description">lazy</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">138</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">15</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">71</span></a></div><a class="site-state-item hty-icon-button" href="/bangumis/index.html" title="bangumi"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-book-2-line"></use></svg></span></a></nav><hr style="margin-bottom:.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="/atom.xml" title="RSS" target="_blank" style="color:orange"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-rss-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://qm.qq.com/cgi-bin/qm/qr?k=DSmoEtSKHITcV9pghYqqmSQ80-SPnPjm&amp;noverify=0" title="QQ" target="_blank" style="color:#12b7f5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/zxjlm" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com/people/Zxj_Butterfly_m/" title="豆瓣" target="_blank" style="color:#072"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-douban-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=305617499" title="网易云音乐" target="_blank" style="color:#c20c0c"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/1801214" title="哔哩哔哩" target="_blank" style="color:#ff8eb3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://twitter.com/Harumonia1996" title="Twitter" target="_blank" style="color:#1da1f2"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-twitter-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:zxjlm233@gmail.com" title="E-Mail" target="_blank" style="color:#8e71c1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:#1e90ff"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color:#f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Data-Structure-That-Power-Your-Database"><span class="toc-number">1.</span> <span class="toc-text">Data Structure That Power Your Database</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash-Index"><span class="toc-number">2.</span> <span class="toc-text">Hash Index</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Compaction"><span class="toc-number">2.1.</span> <span class="toc-text">Compaction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSTables-and-LSM-Trees"><span class="toc-number">2.2.</span> <span class="toc-text">SSTables and LSM-Trees</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%BB%B4%E6%8A%A4-SSTables"><span class="toc-number">2.3.</span> <span class="toc-text">构建与维护 SSTables</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.1.</span> <span class="toc-text">性能优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Tree"><span class="toc-number">2.4.</span> <span class="toc-text">B-Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A9-B-Tree-%E6%9B%B4%E5%8F%AF%E9%9D%A0"><span class="toc-number">2.4.1.</span> <span class="toc-text">让 B-Tree 更可靠</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-B-tree"><span class="toc-number">2.4.2.</span> <span class="toc-text">优化 B-tree</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-B-Tree-%E5%92%8C-LSM-Tree"><span class="toc-number">2.5.</span> <span class="toc-text">对比 B-Tree 和 LSM-Tree</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LSM-Trees-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">2.5.1.</span> <span class="toc-text">LSM-Trees 的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LSM-Trees-%E7%9A%84%E5%8A%A3%E5%8A%BF"><span class="toc-number">2.5.2.</span> <span class="toc-text">LSM-Trees 的劣势</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">3.</span> <span class="toc-text">Reference</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7"><link itemprop="mainEntityOfPage" href="https://blog.harumonia.moe/2022-10-10-C3-Storage-and-Retrieval/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="harumonia"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Zaxon"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C3. Storage and Retrieval (更新中)</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2022-10-10 17:22:24" itemprop="dateCreated datePublished" datetime="2022-10-10T17:22:24+00:00">2022-10-10</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2023-01-07 14:54:24" itemprop="dateModified" datetime="2023-01-07T14:54:24+00:00">2023-01-07</time></div><div class="post-classify"></div><div class="post-author"><div class="author-avatar"><img src="https://www.gravatar.com/avatar/170126958484dfae0e26934864b36b4e?s=20&amp;d=https%3A%2F%2Fcdn.jsdelivr.net%2Fgh%2FYunYouJun%2Fcdn%2Fimg%2Favatar%2Fnone.jpg"></div><span class="author-name">harumonia</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h2 id="Data-Structure-That-Power-Your-Database"><a href="#Data-Structure-That-Power-Your-Database" class="headerlink" title="Data Structure That Power Your Database"></a>Data Structure That Power Your Database</h2><p>最简单的数据库是什么样子的?</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash </span>
<span class="token function-name function">db_set</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     
 <span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$1</span>,<span class="token variable">$2</span>"</span> <span class="token operator">>></span> database 
<span class="token punctuation">&#125;</span> 

<span class="token function-name function">db_get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     
 <span class="token function">grep</span> <span class="token string">"^<span class="token variable">$1</span>,"</span> database <span class="token operator">|</span> <span class="token function">sed</span> -e <span class="token string">"s/^<span class="token variable">$1</span>,//"</span> <span class="token operator">|</span> <span class="token function">tail</span> -n <span class="token number">1</span> 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上所示, 我们完成了一个最简单的 <strong>kv 数据库</strong>. 它的工作原理是: <em>db_set</em> 在文件末尾追加一个 kv 对; 如果对某一个 key 进行更新, 那么新的记录会继续追加写入文件, 而非覆盖; <em>db_get</em> 查询到最后(即最新)一条 key , 然后返回 value.</p><p>这个数据库的<strong>写</strong>效率极高 [ $O(1)$ ], 因为它单纯的就是向文件的末尾进行 <code>append</code> 操作. 但是代价是它的<strong>读</strong>效率非常低 [ $O(n)$ ].</p><p>为了解决读效率低的问题, 可以使用 <code>索引</code> , 索引本质上是一个依附于主体数据的额外的数据结构. 它可以作为一个整体地被添加或者删除. 但是索引又会引发一个新的问题, 索引的变化依托于 <strong>写(write)</strong> 操作, 这意味着每次写都需要额外的一部分性能来更新这个数据结构, 如果数据结构过于复杂, 则会拖慢影响写的效率.</p><p>本节主要就是围绕这些索引结构及其演进来展开.</p><ul><li>Hash Index</li><li>SSTable</li><li>…</li></ul><span id="more"></span><h2 id="Hash-Index"><a href="#Hash-Index" class="headerlink" title="Hash Index"></a><strong>Hash Index</strong></h2><p>Hash Index 的核心是维护一个 <strong>hash map</strong>, 这个数据结构广泛地存在于各个语言之中, 所以不在对其原理做过多的赘述.</p><p><img src="https://raw.githubusercontent.com/zxjlm/my-static-files/main/img/20220818141020.png" alt="Storing a log of key-value pairs in a CSV-like format, indexed with an inmemory hash map." loading="lazy"></p><p>Storing a log of key-value pairs in a CSV-like format, indexed with an inmemory hash map.</p><p>Hash map 为了保证查询效率, 一般是整个放在内存中.</p><p>硬盘中的 log 与内存中的 hash index 组合起来, 就能够提供较高的读写性能 (仅当内存容量 &gt; hash map 大小时).</p><ul><li>写: 依然是文件追加写.</li><li>读: 一次内存查询, 一次磁盘 seek; 如果数据已经被缓存, 则 seek 也可以省掉.</li></ul><h3 id="Compaction"><a href="#Compaction" class="headerlink" title="Compaction"></a><strong>Compaction</strong></h3><p>上文所述的这种通过 <strong>append</strong> 进行写操作的数据库, 这种结构一般称之为 <strong>log-structure.</strong> <em>log-structure</em> 类型的数据库面临的问题主要有二, 除了上文所述的 <strong>低效读</strong>, 另一个问题是, 每一次写操作都会计入 log 文件, 这样很容易让 log 文件过大. 尤其是对于 key 的数量较少且更新频繁的数据, 新数据会导致旧数据失去价值, 从而产生大量的空间浪费. 所以需要一套压缩(<em>Compaction</em>)方案来保证空间使用率.</p><p>压缩的一个解决方案是将 log 文件按照一定的大小分段 (<em>Segment</em>), 当写满一个 segment 之后, 就将该 segment 分离出来进行压缩, 即, 丢弃该 segment 中重复的键, 相同的键仅保留最近一次写入的结果.</p><p><img src="https://raw.githubusercontent.com/zxjlm/my-static-files/main/img/20220818150445.png" alt="Compaction of a key-value update log (counting the number of times each cat video was played), retaining only the most recent value for each key" loading="lazy"></p><p>Compaction of a key-value update log (counting the number of times each cat video was played), retaining only the most recent value for each key</p><p>压缩之后, 旧的 segment 逻辑上占用的空间会大于或等于实际占用的空间, 所以对于这部分的 segment 可以进行合并(merge), 然后重复进行上述的压缩操作. 需要注意都是, 合并操作是在一个新的 segment 中进行的, 压缩之后, 虽然 segment 在实际上出现了空余空间, 但是在逻辑上已经锁定了(<strong>只读</strong>). 在完成合并之后, 旧的 segment 将会被删除.</p><p>每个 segment 都有自己的 Hash Index, 在进行查询时, 会按照时间顺序来进行查询任务.</p><p>log-structure 的数据库乍一看是十分简陋的, 即使有后面的压缩操作, 但依然会浪费很大的一部分空间. 但是对于原地更新型的数据库, 它具有如下的优点与不足:</p><ul><li>Advantages<ol><li>append 操作的效率要高于 update. 因为省略了查询定位的操作. 此外, segment 的大小是固定的, 所以 update 造成的数据块大小的变化很可能会引起 segment 的重建, 造成不必要的开销. 另外, 对于 HDD 来说.</li><li>程序崩溃出错之后能够很快地进行恢复.</li><li>合并操作能够一定程度上避免碎片数据的产生.</li></ol></li><li>Disadvantages<ol><li>Hash index 必须存在于内存中, 如果数据量过大, 很容易内存溢出. (如果将 Hash index 维护于硬盘中, 则会降低索引的性能)</li><li>由于 key 是无序的, 所以对于范围性的查询不友好. ( e.g: 0 &lt; key &lt; 100 )</li></ol></li></ul><h3 id="SSTables-and-LSM-Trees"><a href="#SSTables-and-LSM-Trees" class="headerlink" title="SSTables and LSM-Trees"></a>SSTables and LSM-Trees</h3><p>在之前的优化中, 每一个 segment 都是一个顺序的 kv 对, 它们的顺序只与被 append 的时间相关, 而 kv 本身的顺序无关紧要. 甚至乍一看, 排序操作会丧失顺序写带来的性能优势.</p><p>以 key 为排序基准的结构, 一般被称为 SST (<em>Sorted String Table) .</em> 这种格式有如下的好处:</p><ul><li>合并 segment 变得更为高校, 即使文件比可用内存更大. (参考合并排序算法, 多个 segment 同时进行合并)</li><li>不再需要将全部的 key 维护在内存中. 可以采用 offset 的思路对 key 进行压缩. (0,1,2,3,…. ⇒ 0, 10, 20, ….)</li><li>由于读取请求无论如何都需要扫描所请求范围内的多个键值对，因此可以将这些记录分组到块中，并在将其写入硬盘之前对其进行压缩 (类似json的格式化?)</li></ul><h3 id="构建与维护-SSTables"><a href="#构建与维护-SSTables" class="headerlink" title="构建与维护  SSTables"></a>构建与维护 SSTables</h3><p>SSTables 在数据结构上更加接进 “树(Tree)”. 但是目前这棵树依然是<strong>仅存在于内存中</strong>的.</p><p>维护这个数据结构包含以下的几个工作:</p><ul><li>插入数据时, 保证树结构的平衡(balance), 参考红黑树. 这棵接收数据的树是维护于内存中的(<em>memtable</em>).</li><li>当 SSTable 的容量超过阈值时, 将其转移到硬盘中. 此时这个 SSTable 成为 <em>most recent segment</em>. 在这个转移过程中, 可以开辟一个新的内存空间来维护新的 SSTable.</li><li>当读(read)请求进入时, 先查询内存中的 memtable, 然后是 <em>most recent segment,</em> 以此类推, 直到命中, 返回*.*</li><li>硬盘中的 segments 在不停地进行合并压缩操作.</li></ul><p>当程序发生意外时, 硬盘中的数据不会受损, 但是内存中维护的 mamtable 会丢失, 为了避免这一情况, 最好是对 memtable 留存一份的 <em>append log</em>, 当数据写入硬盘时, 删除对应的 log.</p><blockquote><p>LSM-Trees (Log-Structured Merge-Tree)  consists of some memory components and some disk components. Basically <em>SSTable</em> is just a one implemention of disk component for LSM-tree.</p></blockquote><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><ul><li>对于不存在的 key, 在查询时会遍历完整个 SSTable, 所以可以使用布隆过滤器(<em>Bloom filters</em>)来<strong>降低</strong>这种查询带来的损耗.</li><li>优化压缩策略: <em>size-tiered \ leveled</em> compaction. (压缩策略的优化实际上是”什么情况下压缩哪些内容”的细化, 这里不作深入)</li></ul><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>从结构上看, <strong>B-trees</strong> 与 <strong>SSTables</strong> 相类, 都是维护了一个以 <em>key</em> 排序的键值对, 以高效地进行查询的操作, 但是二者的设计逻辑是大相径庭的.</p><p>如前文所述, log-structured indexes 将数据库分为大小不一的 segments (通常是 MB 或者更大), 并且按序写入硬盘. 与之相反的是, B-trees 将数据库分为大小固定的 blocks 或者 pages (通常是 4KB, 有时会更大), 并且每次读写以页为单位. 由于硬盘也是按照固定大小进行分配的, 所以这种设计更加贴合底层硬件. (有关 page 和 block 的问题可以看<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/22137555/whats-the-difference-between-page-and-block-in-operating-system">这个回答</a>)</p><p>每个 page 都有自己的 id , 用来进行逻辑上的引用, 其引用结构如下图所示.</p><p><img src="https://raw.githubusercontent.com/zxjlm/my-static-files/main/img/20220902161015.png" alt="Looking up a key using a B-tree index." loading="lazy"></p><p>Looking up a key using a B-tree index.</p><p>每个 page 包含的子页面的数量被称为<strong>分支因子</strong>(<em>branch factor</em>), 上图中的分支因子数量即为6. 通常, 分支因子的数量为几百个.</p><p>该图展示了一个查询的实际过程. 本质上是一个二分查找, 从根节点出发, 查找对应的区间, 直到命中 叶子节点 (leaf page) .</p><p>在对索引树进行修改时, 遵循如下的算法.</p><p>在<strong>更新</strong>的时候, 数据库根据索引定位到叶子节点, 然后将对应的数据进行更新, 最后将页回写到硬盘. 而在<strong>插入</strong>新数据的时候, 会按照既定的顺序插入索引树. 当没有足够的空间来插入 key 的时候, 会将当前页对半分解为两个新页, 然后再进行更新.</p><p>这套算法保证了索引树是一个平衡树, 也就是拥有 n 个 key 的 B-tree 深度为 $O(\log n)$. 大多数数据库的 B-tree 深度为 3 or 4 层.</p><p>$StorageSize = BranchingFactor ^ {depth} * BlockSize$</p><h4 id="让-B-Tree-更可靠"><a href="#让-B-Tree-更可靠" class="headerlink" title="让 B-Tree 更可靠"></a>让 B-Tree 更可靠</h4><p>B-Tree 的写操作是直接在硬盘上以 page 为单位进行覆盖. 某些操作(如需要分裂 page 的更新)会导致数个 page 进行级联变动, 如果在变动的过程中出现了程序崩溃, 那么索引树就会在结构上产生溃烂.</p><p>为了保证B树能够具有这样的<strong>抗崩溃(anti-crash)能力</strong>, 通常会在硬盘上外置一个数据结构, <em>write-ahead log</em>(WAL, also known as a <em>redo log</em>). 顾名思义, 它会将所有的修改操作记录下来, 在程序发生中断时用来进行恢复.</p><p>另一个需要考虑的是<strong>并发控制</strong>, 树结构通常使用 <em>latches</em> 来确保并发安全性. log-sturcture 在这方面要简单得多, 因为所有的合并操作都是在后台中进行, 不会受到查询的干扰.</p><blockquote><p><a target="_blank" rel="noopener" href="https://dsf.berkeley.edu/jmh/cs262b/treeCCR.html">Latches vs. Locks</a>:</p><ul><li>Latches, like mutexes, are on physical memory addresses (in bufPool). Cheap to allocate and set. Locks are on externally visible data, and named in a lock table that has a lot of data structure support (hash at least by lockname and by xact). So expensive to allocated and set (10x latches).</li><li>Latches, like mutexes, are held “as long as needed”. Locks are held to transaction boundaries.</li></ul></blockquote><h4 id="优化-B-tree"><a href="#优化-B-tree" class="headerlink" title="优化 B-tree"></a>优化 B-tree</h4><ul><li>取 WAL 代之, 使用 <strong>copy-on-write(COW)</strong> 方案. 即, 将修改页复制到另一个地址(location), 在这个新页面进行修改, 修改完毕之后, 将父页面的引用更新. 这个方案同样适用于并发控制. Q: 只保证了原始数据, 中断恢复如何进行?</li><li>不直接存储完整的 key , 而是进行压缩. 特别是在 tree 的内部的页面中，key 只需要提供足够的信息来作为范围之间的边界. 压缩 key 意味着 tree 能够有更多的分支因子, 从而降低 tree 的高度(levels).</li><li>pages 可以存放在硬盘的任何地方, 所以在进行范围查询的时候, 这种布局设计是非常低效的. 所以有些 B-Tree 会将叶子节点有序地存储在硬盘上, 由此能够进行高效的范围查询, 但是代价是维护成本会随着 tree 的生长愈发困难.</li><li>为每个叶子节点添加兄弟指针, 这样可以避免遍历时需要到父节点查找下一个 page 的情况(回溯).</li><li>借鉴 log-structure 的一些特性来进行优化, 由此衍生出一些 B-tree 的变种.</li></ul><h3 id="对比-B-Tree-和-LSM-Tree"><a href="#对比-B-Tree-和-LSM-Tree" class="headerlink" title="对比 B-Tree 和 LSM-Tree"></a>对比 B-Tree 和 LSM-Tree</h3><p>从经验上看, B-Trees 在读(read)方面更快, 而 LSM-trees 在写(write) 方面更快.</p><p>但是, 基准(benchmarks) 往往是不确定的，对工作负载的细节很敏感. 你需要用特定工作负载(workload)来进行测试, 以便进行有效的比较。</p><h4 id="LSM-Trees-的优势"><a href="#LSM-Trees-的优势" class="headerlink" title="LSM-Trees 的优势"></a>LSM-Trees 的优势</h4><p>一个 B-tree 索引的每段数据会至少写两遍: 一遍是 WAL, 一遍是 page. 每次更改数据都会复写整个 page, 部分引擎会复写多次. Log-Structure 索引由于 Compaction 和 merging of SSTables, 同样会重写多次. 这种入库生命周期内多次写入的行为, 被称为 “<em>write amplification</em>”. (SSD比较特殊, 由于它的磨损机制, 所以只能进行有限次数的重写.)</p><p>在需要进行大量<strong>”写”操作</strong>的应用中, 性能瓶颈通常在数据库到对硬盘的写入速率. 所以 <em>write amplification</em> 越低的, 效率越高.</p><p>LSM-Trees 的写入能力更高. 原因如下:</p><ul><li>拥有更低的 write amplification (尽管这取决于存储引擎的配置和工作负载)</li><li>顺序写(sequential write)的机制更加符合磁盘的设计 (B-Tree是随机写, in place)</li></ul><p>此外, LSM-Trees 能够进行更好的压缩, 占用的空间更小. B-tree 由于分页机制, 如果 page 写不满, 从而形成碎片(fragmentation) , 造成空间浪费. LSM-Trees 则会对碎片进行整理与压缩.</p><p>在许多的 SSD 上, 固件在内部使用了一种日志结构的算法, 在底层的存储芯片上将随机的写入转化为连续的写入, 所以存储引擎的写入模式的影响不太明显. 但是 <strong>较低的 write amplification</strong> 和 <strong>较少的碎片文件</strong> 仍然是有利的.</p><h4 id="LSM-Trees-的劣势"><a href="#LSM-Trees-的劣势" class="headerlink" title="LSM-Trees 的劣势"></a>LSM-Trees 的劣势</h4><p>LSM-Tree 的压缩进程一直在后台进行读写操作, 占用了有限的系统资源, 有时这种操作会妨碍到服务的性能,尤其是在进行代价较大的压缩操作时, 甚至会阻塞正常的请求. 相比之下, B-Tree 的性能表现更加稳定.</p><p>另一个压缩会引发的问题是, 在高写入量时, 磁盘有限的写入带宽需要在初始写入(logging和刷新memtable到硬盘)和在后台运行的压缩线程之间共享. 随着数据库的增加, 压缩线程占用的资源也会更多. 如果写入吞吐量很高, 并且压缩没有仔细配置, 压缩跟不上写入速率. 在这种情况下, 磁盘上未合并段的数量不断增加, 直到磁盘空间用完, 读取速度也会减慢, 因为它们需要检查更多段文件.</p><p>B-Tree 的一个优点是每个键只存在于索引中的一个位置, 而日志结构化的存储引擎可能在不同的段中有相同键的多个副本. 这个方面使得 B-Tree 在想要提供强大的事务语义的数据库中很有吸引力: 在许多关系数据库中, 事务隔离是通过在键范围上使用锁来实现的, 在B树索引中, 这些锁可以直接连接到树.</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>Martin Kleppmann : “<em>Designing Data-Intensive Application”</em></li><li>Rui Huang : “<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/22137555/whats-the-difference-between-page-and-block-in-operating-system"><em>What’s the difference between page and block in operating system?</em></a><strong>”</strong></li><li>木鸟杂记 <strong>: ”**<em>DDIA 读书笔记（三）：B-Tree 和 LSM-Tree</em></strong>”**</li><li>berkeley - cs262b : “<em>Concurrency Control and Recovery for Search Trees</em>”</li></ol></div></section><div id="reward-container"><span class="hty-icon-button button-glow" id="reward-button" title="打赏" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === &quot;none&quot;) ? &quot;block&quot; : &quot;none&quot;;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-hand-coin-line"></use></svg></span><div id="reward-comment">I'm so cute. Please give me money.</div><div id="qr" style="display:none"><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://harumona-blog.oss-cn-beijing.aliyuncs.com/blog/IMG_3741.JPG"><img loading="lazy" src="https://harumona-blog.oss-cn-beijing.aliyuncs.com/blog/IMG_3741.JPG" alt="支付宝" title="支付宝"></a><div><span style="color:#00a3ee"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-alipay-line"></use></svg></span></div></div><div style="display:inline-block"></div><div style="display:inline-block"><a target="_blank" rel="noopener" href="https://harumona-blog.oss-cn-beijing.aliyuncs.com/blog/IMG_3742.JPG"><img loading="lazy" src="https://harumona-blog.oss-cn-beijing.aliyuncs.com/blog/IMG_3742.JPG" alt="微信支付" title="微信支付"></a><div><span style="color:#2dc100"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-wechat-pay-line"></use></svg></span></div></div></div></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>harumonia</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://blog.harumonia.moe/2022-10-10-C3-Storage-and-Retrieval/" title="C3. Storage and Retrieval (更新中)">https://blog.harumonia.moe/2022-10-10-C3-Storage-and-Retrieval/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022-11-14-pytest-mock-counter/" rel="prev" title="2022-11-14-pytest_mock_counter"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">2022-11-14-pytest_mock_counter</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2022-4-7/" rel="next" title="2022.4~.7 生活小结"><span class="post-nav-text">2022.4~.7 生活小结</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2018 – 2023 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author">harumonia</span></div><div class="live-time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2018-10-25T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();</script></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" target="_blank" rel="noopener" href="https://www.google.com/search?q=site:harumonia.moe" title="搜索"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:search-line"></span></span></a></body></html>